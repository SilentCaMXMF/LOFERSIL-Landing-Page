/**
 * Tests for PR Generator Component
 */

import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import {
  PRGenerator,
  PullRequest,
} from "../../../../src/scripts/modules/../../../src/scripts/modules/github-issues/PRGenerator";
import { OpenCodeAgent } from "../../../../src/scripts/modules/OpenCodeAgent";
import { ResolutionResult } from "../../../../src/scripts/modules/../../../src/scripts/modules/github-issues/AutonomousResolver";
import { ReviewResult } from "../../../../src/scripts/modules/../../../src/scripts/modules/github-issues/CodeReviewer";

// Mock dependencies
vi.mock("../OpenCodeAgent");

describe("PRGenerator", () => {
  let mockAgent: any;
  let generator: PRGenerator;

  const mockConfig = {
    openCodeAgent: {} as OpenCodeAgent,
    githubToken: "mock-token",
    repository: {
      owner: "test-owner",
      name: "test-repo",
    },
    baseBranch: "main",
    commitMessageTemplate: "{type}({scope}): {description}",
    prTitleTemplate: "{type}: {description}",
    prBodyTemplate: "## Changes\n{changes}\n\n## Review\n{review}",
    defaultReviewers: ["default-reviewer"],
    labels: {
      autoGenerated: "ai-generated",
      needsReview: "needs-review",
      security: "security",
      breaking: "breaking-change",
    },
    maxCommitMessageLength: 100,
    maxPRTitleLength: 80,
  };

  const mockResolution: ResolutionResult = {
    success: true,
    solution: {
      files: [
        {
          path: "src/components/LoginForm.ts",
          changes: [
            {
              type: "modify",
              content:
                'function validateEmail(email: string): boolean {\n  return email.includes("@");\n}',
            },
          ],
        },
      ],
    },
    worktree: {
      branch: "ai-fix/issue-123-login-validation",
      path: "/tmp/worktree-123",
      issueId: 123,
      createdAt: new Date(),
      status: "active",
    },
    iterations: 1,
    reasoning: "Successfully implemented email validation",
  };

  const mockReview: ReviewResult = {
    approved: true,
    score: 0.85,
    issues: [
      {
        type: "warning",
        category: "quality",
        severity: "low",
        message: "Consider adding JSDoc comments",
        file: "src/components/LoginForm.ts",
      },
    ],
    recommendations: ["Add comprehensive tests"],
    reasoning: "Code quality is good with minor improvements needed",
    metadata: {
      staticAnalysisScore: 0.9,
      securityScore: 1.0,
      qualityScore: 0.8,
      testCoverageScore: 0.7,
      performanceScore: 0.9,
      documentationScore: 0.6,
    },
  };

  const mockIssue = {
    number: 123,
    title: "Fix login validation bug",
    body: "The login form validation is not working properly.\n\nRequirements:\n- Add email validation\n- Show error messages",
  };

  beforeEach(() => {
    mockAgent = {
      query: vi.fn(),
    };
    mockConfig.openCodeAgent = mockAgent;
    generator = new PRGenerator(mockConfig);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe("createPullRequest", () => {
    it("should create a complete pull request successfully", async () => {
      // Mock AI responses
      mockAgent.query
        .mockResolvedValueOnce("feat(auth): implement email validation")
        .mockResolvedValueOnce(
          "## ðŸ¤– AI-Generated Pull Request\n\n**Original Issue:** #123 - Fix login validation bug\n**Resolution Status:** Successful\n**Review Status:** âœ… Approved (Score: 85.0%)\n**Complexity:** Low\n\nThis pull request was automatically generated to resolve the linked issue.",
        );

      // Mock GitHub API - using deterministic values based on mock implementation
      const mockPR: PullRequest = {
        number: 460, // Deterministic based on mock implementation
        title: "feat!: change API signature", // Breaking change detected in fallback
        body: "Mock PR body",
        html_url: "https://github.com/test-owner/test-repo/pull/460",
        state: "open",
        merged: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      // Mock the GitHub API call
      generator["createGitHubPR"] = vi.fn().mockResolvedValue(mockPR);

      const result = await generator.createPullRequest(
        mockResolution,
        mockReview,
        mockIssue,
      );

      // Compare excluding timestamps which vary due to timing
      expect(result.number).toBe(mockPR.number);
      expect(result.title).toBe(mockPR.title);
      expect(result.body).toBe(mockPR.body);
      expect(result.html_url).toBe(mockPR.html_url);
      expect(result.state).toBe(mockPR.state);
      expect(result.merged).toBe(mockPR.merged);
      expect(mockAgent.query).toHaveBeenCalledTimes(1); // Only title uses AI
      expect(generator["createGitHubPR"]).toHaveBeenCalledWith({
        title: expect.stringContaining("feat"),
        body: expect.stringContaining("AI-Generated Pull Request"),
        head: "ai-fix/issue-123-login-validation",
        base: "main",
        reviewers: expect.arrayContaining(["default-reviewer"]),
        labels: expect.arrayContaining(["ai-generated"]),
      });
    });

    it("should handle AI generation failures gracefully", async () => {
      mockAgent.query.mockRejectedValue(new Error("AI service unavailable"));

      const mockPR: PullRequest = {
        number: 457,
        title: "feat: Fix login validation bug",
        body: "Fallback PR body",
        html_url: "https://github.com/test-owner/test-repo/pull/457",
        state: "open",
        merged: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      generator["createGitHubPR"] = vi.fn().mockResolvedValue(mockPR);

      const result = await generator.createPullRequest(
        mockResolution,
        mockReview,
        mockIssue,
      );

      expect(result.title).toMatch(/feat[!:]/); // Matches "feat:" or "feat!:" (breaking change)
      expect(result.title).toContain("Fix login validation bug");
    });

    it("should assign appropriate reviewers based on change scope", async () => {
      const frontendChanges = {
        ...mockResolution,
        solution: {
          files: [
            {
              path: "src/components/LoginForm.tsx",
              changes: [
                { type: "modify", content: "const component = () => <div/>;" },
              ],
            },
          ],
        },
      };

      mockAgent.query
        .mockResolvedValueOnce("feat(ui): update login form")
        .mockResolvedValueOnce("Mock PR body");

      const mockPR: PullRequest = {
        number: 458,
        title: "feat(ui): update login form",
        body: "Mock PR body",
        html_url: "https://github.com/test-owner/test-repo/pull/458",
        state: "open",
        merged: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      generator["createGitHubPR"] = vi.fn().mockResolvedValue(mockPR);

      await generator.createPullRequest(frontendChanges, mockReview, mockIssue);

      expect(generator["createGitHubPR"]).toHaveBeenCalledWith(
        expect.objectContaining({
          reviewers: expect.arrayContaining([
            "default-reviewer",
            "frontend-lead",
          ]),
        }),
      );
    });

    it("should add security reviewers for security issues", async () => {
      const securityReview = {
        ...mockReview,
        issues: [
          {
            type: "error",
            category: "security",
            severity: "high",
            message: "SQL injection vulnerability detected",
          },
        ],
      };

      mockAgent.query
        .mockResolvedValueOnce("fix(security): prevent SQL injection")
        .mockResolvedValueOnce("Mock PR body");

      const mockPR: PullRequest = {
        number: 459,
        title: "fix(security): prevent SQL injection",
        body: "Mock PR body",
        html_url: "https://github.com/test-owner/test-repo/pull/459",
        state: "open",
        merged: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      generator["createGitHubPR"] = vi.fn().mockResolvedValue(mockPR);

      await generator.createPullRequest(
        mockResolution,
        securityReview,
        mockIssue,
      );

      expect(generator["createGitHubPR"]).toHaveBeenCalledWith(
        expect.objectContaining({
          reviewers: expect.arrayContaining([
            "default-reviewer",
            "security-lead",
            "compliance-officer",
          ]),
          labels: expect.arrayContaining(["ai-generated", "security"]),
        }),
      );
    });

    it("should add breaking change labels when detected", async () => {
      const breakingChanges = {
        ...mockResolution,
        solution: {
          files: [
            {
              path: "src/api/v1/auth.ts",
              changes: [
                {
                  type: "modify",
                  content:
                    "BREAKING: Changed API signature\noldMethod() -> newMethod(param)",
                },
              ],
            },
          ],
        },
      };

      mockAgent.query
        .mockResolvedValueOnce("feat!: change API signature")
        .mockResolvedValueOnce("Mock PR body");

      const mockPR: PullRequest = {
        number: 460,
        title: "feat!: change API signature",
        body: "Mock PR body",
        html_url: "https://github.com/test-owner/test-repo/pull/460",
        state: "open",
        merged: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      generator["createGitHubPR"] = vi.fn().mockResolvedValue(mockPR);

      await generator.createPullRequest(breakingChanges, mockReview, mockIssue);

      expect(generator["createGitHubPR"]).toHaveBeenCalledWith(
        expect.objectContaining({
          labels: expect.arrayContaining(["ai-generated", "breaking-change"]),
        }),
      );
    });
  });

  describe("generatePRTitle", () => {
    it("should generate meaningful PR titles using AI", async () => {
      mockAgent.query.mockResolvedValue(
        "feat(auth): implement robust email validation",
      );

      const title = await generator["generatePRTitle"](
        mockResolution,
        mockReview,
        mockIssue,
      );

      expect(title).toBe("feat(auth): implement robust email validation");
      expect(mockAgent.query).toHaveBeenCalledWith(
        expect.stringContaining(
          "Generate a concise, meaningful pull request title",
        ),
        expect.any(Object),
      );
    });

    it("should fall back to template-based titles", async () => {
      mockAgent.query.mockRejectedValue(new Error("AI failed"));

      const title = await generator["generatePRTitle"](
        mockResolution,
        mockReview,
        mockIssue,
      );

      expect(title).toContain("feat");
      expect(title).toContain("Fix login validation bug");
    });

    it("should truncate long titles", async () => {
      mockAgent.query.mockResolvedValue("A".repeat(100)); // Very long title

      const title = await generator["generatePRTitle"](
        mockResolution,
        mockReview,
        mockIssue,
      );

      expect(title.length).toBeLessThanOrEqual(mockConfig.maxPRTitleLength);
    });
  });

  describe("generatePRDescription", () => {
    it("should create comprehensive PR descriptions", async () => {
      const commits = [
        { message: "feat: implement email validation", hash: "abc123" },
        { message: "test: add validation tests", hash: "def456" },
      ];

      const description = await generator["generatePRDescription"](
        mockResolution,
        mockReview,
        mockIssue,
        commits,
      );

      expect(description).toContain("ðŸ¤– AI-Generated Pull Request");
      expect(description).toContain("**Original Issue:** #123");
      expect(description).toContain("**Review Status:** âœ… Approved");
      expect(description).toContain("Changes Summary");
      expect(description).toContain("Code Review Results");
      expect(description).toContain("Testing Information");
      expect(description).toContain("Commits");
      expect(description).toContain("**Closes:** #123");
    });

    it("should include review recommendations when present", async () => {
      const reviewWithRecommendations = {
        ...mockReview,
        recommendations: ["Add more tests", "Improve documentation"],
      };

      const description = await generator["generatePRDescription"](
        mockResolution,
        reviewWithRecommendations,
        mockIssue,
        [],
      );

      expect(description).toContain("Recommendations:");
      expect(description).toContain("Add more tests");
      expect(description).toContain("Improve documentation");
    });
  });

  describe("determineReviewers", () => {
    it("should include default reviewers", async () => {
      const reviewers = await generator["determineReviewers"](
        mockResolution,
        mockReview,
        mockIssue,
      );

      expect(reviewers).toContain("default-reviewer");
    });

    it("should add scope-specific reviewers", async () => {
      const frontendResolution = {
        ...mockResolution,
        solution: {
          files: [
            {
              path: "src/components/Button.tsx",
              changes: [{ type: "modify", content: "updated component" }],
            },
          ],
        },
      };

      const reviewers = await generator["determineReviewers"](
        frontendResolution,
        mockReview,
        mockIssue,
      );

      expect(reviewers).toContain("frontend-lead");
    });

    it("should add senior reviewers for complex changes", async () => {
      const complexResolution = {
        ...mockResolution,
        solution: {
          files: Array(10)
            .fill(null)
            .map((_, i) => ({
              path: `src/file${i}.ts`,
              changes: [{ type: "add", content: "complex code" }],
            })),
        },
      };

      const reviewers = await generator["determineReviewers"](
        complexResolution,
        mockReview,
        mockIssue,
      );

      expect(reviewers).toContain("tech-lead");
      expect(reviewers).toContain("architect");
    });
  });

  describe("determineLabels", () => {
    it("should include auto-generated label", () => {
      const labels = generator["determineLabels"](
        mockResolution,
        mockReview,
        mockIssue,
      );

      expect(labels).toContain("ai-generated");
    });

    it("should add needs-review label for unapproved PRs", () => {
      const unapprovedReview = { ...mockReview, approved: false };

      const labels = generator["determineLabels"](
        mockResolution,
        unapprovedReview,
        mockIssue,
      );

      expect(labels).toContain("needs-review");
    });

    it("should add security label for security issues", () => {
      const securityReview = {
        ...mockReview,
        issues: [
          {
            type: "error",
            category: "security",
            severity: "high",
            message: "Security vulnerability",
          },
        ],
      };

      const labels = generator["determineLabels"](
        mockResolution,
        securityReview,
        mockIssue,
      );

      expect(labels).toContain("security");
    });

    it("should add size labels based on PR size", () => {
      const largeResolution = {
        ...mockResolution,
        solution: {
          files: Array(15)
            .fill(null)
            .map((_, i) => ({
              path: `src/large${i}.ts`,
              changes: [{ type: "add", content: "large change" }],
            })),
        },
      };

      const labels = generator["determineLabels"](
        largeResolution,
        mockReview,
        mockIssue,
      );

      expect(labels).toContain("size/large");
    });
  });

  describe("createCommits", () => {
    it("should create commits from changes", async () => {
      // Mock git operations
      generator["gitAdd"] = vi.fn().mockResolvedValue(undefined);
      generator["gitCommit"] = vi.fn().mockResolvedValue("mock-hash-123");
      generator["gitPush"] = vi.fn().mockResolvedValue(undefined);

      const commits = await generator["createCommits"](
        mockResolution.solution,
        "test-branch",
      );

      expect(commits).toHaveLength(1);
      expect(commits[0]).toEqual({
        message: expect.stringContaining("feat"),
        hash: "mock-hash-123",
      });
      expect(generator["gitAdd"]).toHaveBeenCalledWith(
        "src/components/LoginForm.ts",
      );
      expect(generator["gitCommit"]).toHaveBeenCalled();
      expect(generator["gitPush"]).toHaveBeenCalledWith("test-branch");
    });

    it("should generate appropriate commit messages", async () => {
      const commitMessage = await generator["generateCommitMessage"]({
        files: [{ path: "src/auth/login.ts" }],
        description: "implement login validation",
      });

      expect(commitMessage).toContain("feat");
      expect(commitMessage).toContain("implement login validation");
    });
  });

  describe("utility methods", () => {
    it("should summarize changes correctly", () => {
      const summary = generator["summarizeChanges"](mockResolution.solution);

      expect(summary).toContain("1 changes across 1 files");
    });

    it("should infer issue types correctly", () => {
      expect(
        generator["inferIssueType"]({ number: 1, title: "Fix bug", body: "" }),
      ).toBe("bug");
      expect(
        generator["inferIssueType"]({
          number: 1,
          title: "Add feature",
          body: "",
        }),
      ).toBe("feature");
      expect(
        generator["inferIssueType"]({
          number: 1,
          title: "Update docs",
          body: "",
        }),
      ).toBe("documentation");
    });

    it("should calculate PR size correctly", () => {
      const smallPR = generator["calculatePRSize"]({
        files: [{ changes: [{}] }],
      });
      const mediumPR = generator["calculatePRSize"]({
        files: Array(5).fill({ changes: [{}] }),
      });
      const largePR = generator["calculatePRSize"]({
        files: Array(15).fill({ changes: [{}] }),
      });

      expect(smallPR).toBe("small");
      expect(mediumPR).toBe("medium");
      expect(largePR).toBe("large");
    });

    it("should detect breaking changes", () => {
      const breakingSolution = {
        files: [
          {
            changes: [
              {
                content: "BREAKING: Changed API signature",
              },
            ],
          },
        ],
      };

      const nonBreakingSolution = {
        files: [
          {
            changes: [
              {
                content: "Minor improvement",
              },
            ],
          },
        ],
      };

      expect(generator["isBreakingChange"](breakingSolution)).toBe(true);
      expect(generator["isBreakingChange"](nonBreakingSolution)).toBe(false);
    });

    it("should estimate test coverage", () => {
      const withTests = {
        files: [
          {
            path: "src/auth/login.test.ts",
            changes: [{}],
          },
        ],
      };

      const withoutTests = {
        files: [
          {
            path: "src/auth/login.ts",
            changes: [{}],
          },
        ],
      };

      expect(generator["estimateTestCoverage"](withTests)).toBe(80);
      expect(generator["estimateTestCoverage"](withoutTests)).toBe(0);
    });
  });

  describe("constructor and config validation", () => {
    it("should accept different config options", () => {
      const customConfig = {
        ...mockConfig,
        maxCommitMessageLength: 200,
        maxPRTitleLength: 100,
        defaultReviewers: ["custom-reviewer"],
      };

      const customGenerator = new PRGenerator(customConfig);
      expect(customGenerator).toBeDefined();
    });

    it("should handle minimal config", () => {
      const minimalConfig = {
        ...mockConfig,
        defaultReviewers: [],
        labels: {
          autoGenerated: "test",
          needsReview: "review",
          security: "sec",
          breaking: "break",
        },
      };

      const minimalGenerator = new PRGenerator(minimalConfig);
      expect(minimalGenerator).toBeDefined();
    });
  });

  describe("PR creation with various change types", () => {
    it("should create PR for documentation changes", async () => {
      const docsIssue = {
        number: 124,
        title: "Update documentation",
        body: "Please update the README with new features",
      };

      const docsResolution = {
        ...mockResolution,
        solution: {
          files: [
            {
              path: "README.md",
              changes: [
                {
                  type: "modify",
                  content: "Updated documentation",
                },
              ],
            },
          ],
        },
      } as any;

      mockAgent.query
        .mockResolvedValueOnce("docs: update README")
        .mockResolvedValueOnce("Mock PR body");

      const mockPR: PullRequest = {
        number: 461,
        title: "docs: update README",
        body: "Mock PR body",
        html_url: "https://github.com/test-owner/test-repo/pull/461",
        state: "open",
        merged: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      generator["createGitHubPR"] = vi.fn().mockResolvedValue(mockPR);

      const result = await generator.createPullRequest(
        docsResolution as any,
        mockReview,
        docsIssue,
      );

      expect(result).toEqual(mockPR);
      expect(generator["createGitHubPR"]).toHaveBeenCalledWith(
        expect.objectContaining({
          labels: expect.arrayContaining(["ai-generated"]),
        }),
      );
    });

    it("should create PR for feature changes", async () => {
      const featureIssue = {
        number: 125,
        title: "Add new feature",
        body: "Implement user authentication feature",
      };

      mockAgent.query
        .mockResolvedValueOnce("feat: implement user authentication")
        .mockResolvedValueOnce("Mock PR body");

      const mockPR: PullRequest = {
        number: 462,
        title: "feat: implement user authentication",
        body: "Mock PR body",
        html_url: "https://github.com/test-owner/test-repo/pull/462",
        state: "open",
        merged: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      };

      generator["createGitHubPR"] = vi.fn().mockResolvedValue(mockPR);

      const result = await generator.createPullRequest(
        mockResolution,
        mockReview,
        featureIssue,
      );

      expect(result).toEqual(mockPR);
    });
  });

  describe("label inference for different scenarios", () => {
    it("should add size labels for large PRs", () => {
      const largeResolution: ResolutionResult = {
        ...mockResolution,
        solution: {
          files: Array(20)
            .fill(null)
            .map((_, i) => ({
              path: `src/large${i}.ts`,
              changes: [{ type: "add", content: "large change" }],
            })),
        },
      };

      const labels = generator["determineLabels"](
        largeResolution,
        mockReview,
        mockIssue,
      );

      expect(labels).toContain("size/large");
    });

    it("should add size labels for medium PRs", () => {
      const mediumResolution: ResolutionResult = {
        ...mockResolution,
        solution: {
          files: Array(5)
            .fill(null)
            .map((_, i) => ({
              path: `src/medium${i}.ts`,
              changes: [{ type: "modify", content: "medium change" }],
            })),
        },
      };

      const labels = generator["determineLabels"](
        mediumResolution,
        mockReview,
        mockIssue,
      );

      expect(labels).toContain("size/medium");
    });

    it("should handle multiple label conditions", () => {
      const complexReview: ReviewResult = {
        ...mockReview,
        approved: false,
        issues: [
          {
            type: "error",
            category: "security",
            severity: "high",
            message: "Security vulnerability",
            file: "src/api.ts",
          },
        ],
      };

      const breakingResolution: ResolutionResult = {
        ...mockResolution,
        solution: {
          files: [
            {
              path: "src/api.ts",
              changes: [
                {
                  type: "modify",
                  content: "BREAKING: Changed API signature",
                },
              ],
            },
          ],
        },
      };

      const labels = generator["determineLabels"](
        breakingResolution,
        complexReview,
        mockIssue,
      );

      expect(labels).toContain("ai-generated");
      expect(labels).toContain("needs-review");
      expect(labels).toContain("security");
      expect(labels).toContain("breaking-change");
    });
  });

  describe("GitHub API error handling", () => {
    it("should handle GitHub API failures gracefully", async () => {
      mockAgent.query
        .mockResolvedValueOnce("feat: test title")
        .mockResolvedValueOnce("Test body");

      generator["createGitHubPR"] = vi
        .fn()
        .mockRejectedValue(new Error("GitHub API rate limit exceeded"));

      await expect(
        generator.createPullRequest(mockResolution, mockReview, mockIssue),
      ).rejects.toThrow("PR creation failed: GitHub API rate limit exceeded");
    });

    it("should handle network errors in GitHub API", async () => {
      mockAgent.query
        .mockResolvedValueOnce("feat: test title")
        .mockResolvedValueOnce("Test body");

      generator["createGitHubPR"] = vi
        .fn()
        .mockRejectedValue(new Error("Network timeout"));

      await expect(
        generator.createPullRequest(mockResolution, mockReview, mockIssue),
      ).rejects.toThrow("PR creation failed: Network timeout");
    });
  });

  describe("error handling", () => {
    it("should handle PR creation failures", async () => {
      mockAgent.query
        .mockResolvedValueOnce("feat: test title")
        .mockResolvedValueOnce("Test body");

      generator["createGitHubPR"] = vi
        .fn()
        .mockRejectedValue(new Error("GitHub API error"));

      await expect(
        generator.createPullRequest(mockResolution, mockReview, mockIssue),
      ).rejects.toThrow("PR creation failed: GitHub API error");
    });

    it("should handle commit creation failures", async () => {
      generator["gitCommit"] = vi
        .fn()
        .mockRejectedValue(new Error("Git commit failed"));

      await expect(
        generator["createCommits"](mockResolution.solution, "test-branch"),
      ).rejects.toThrow("Git commit failed");
    });
  });
});
