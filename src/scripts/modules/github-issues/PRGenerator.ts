/**
 * PR Generator Component
 *
 * Creates and manages GitHub pull requests with proper documentation and automation.
 * Handles commit generation, PR creation, reviewer assignment, and branch management.
 */

import { OpenCodeAgent } from "../OpenCodeAgent";
import { WorktreeInfo } from "./WorktreeManager";
import { ResolutionResult } from "./AutonomousResolver";
import { ReviewResult } from "./CodeReviewer";

export interface PullRequest {
  number: number;
  title: string;
  body: string;
  html_url: string;
  state: "open" | "closed";
  merged: boolean;
  created_at: string;
  updated_at: string;
}

export interface PRGeneratorConfig {
  openCodeAgent: OpenCodeAgent;
  githubToken: string;
  repository: {
    owner: string;
    name: string;
  };
  baseBranch: string;
  commitMessageTemplate: string;
  prTitleTemplate: string;
  prBodyTemplate: string;
  defaultReviewers: string[];
  labels: {
    autoGenerated: string;
    needsReview: string;
    security: string;
    breaking: string;
  };
  maxCommitMessageLength: number;
  maxPRTitleLength: number;
}

export class PRGenerator {
  private config: PRGeneratorConfig;

  constructor(config: PRGeneratorConfig) {
    this.config = config;
  }

  /**
   * Create a pull request from the resolution result
   */
  async createPullRequest(
    resolution: ResolutionResult,
    review: ReviewResult,
    originalIssue: { number: number; title: string; body: string },
  ): Promise<PullRequest> {
    try {
      // Generate branch name if not already created
      const branchName = resolution.worktree.branch;

      // Create commits from the changes
      const commits = await this.createCommits(resolution.solution, branchName);

      // Generate PR title
      const prTitle = await this.generatePRTitle(
        resolution,
        review,
        originalIssue,
      );

      // Generate PR description
      const prBody = await this.generatePRDescription(
        resolution,
        review,
        originalIssue,
        commits,
      );

      // Determine reviewers
      const reviewers = await this.determineReviewers(
        resolution,
        review,
        originalIssue,
      );

      // Determine labels
      const labels = this.determineLabels(
        resolution,
        review,
        originalIssue,
        prTitle,
      );

      // Create the PR
      const pr = await this.createGitHubPR({
        title: prTitle,
        body: prBody,
        head: branchName,
        base: this.config.baseBranch,
        reviewers,
        labels,
      });

      // Update worktree status
      await this.updateWorktreeStatus(resolution.worktree, pr);

      return pr;
    } catch (error) {
      console.error("Failed to create pull request:", error);
      throw new Error(
        `PR creation failed: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Create commits from the code changes
   */
  private async createCommits(
    changes: ResolutionResult["solution"],
    branchName: string,
  ): Promise<Array<{ message: string; hash: string }>> {
    const commits: Array<{ message: string; hash: string }> = [];

    try {
      // Group changes by logical commits
      const commitGroups = this.groupChangesForCommits(changes);

      for (const group of commitGroups) {
        // Stage the files
        for (const file of group.files) {
          await this.gitAdd(file.path);
        }

        // Generate commit message
        const commitMessage = await this.generateCommitMessage(group);

        // Create commit
        const hash = await this.gitCommit(commitMessage);

        commits.push({
          message: commitMessage,
          hash,
        });
      }

      // Push to remote
      await this.gitPush(branchName);
    } catch (error) {
      console.error("Failed to create commits:", error);
      throw error;
    }

    return commits;
  }

  /**
   * Generate an appropriate PR title
   */
  private async generatePRTitle(
    resolution: ResolutionResult,
    review: ReviewResult,
    originalIssue: { number: number; title: string; body: string },
  ): Promise<string> {
    // Use AI to generate a concise, meaningful title
    const prompt = `Generate a concise, meaningful pull request title for the following changes:

Original Issue: #${originalIssue.number} - ${originalIssue.title}
Changes Summary: ${this.summarizeChanges(resolution.solution)}
Review Status: ${review.approved ? "Approved" : "Needs Review"} (Score: ${(review.score * 100).toFixed(1)}%)

Requirements: Keep under ${this.config.maxPRTitleLength} characters, be descriptive but concise, follow conventional commit style if applicable.`;

    try {
      const aiTitle = await this.config.openCodeAgent.query(prompt, {
        maxTokens: 50,
        temperature: 0.3,
      });

      // Clean and validate the title
      const cleanTitle = aiTitle.trim().replace(/^["']|["']$/g, "");
      if (
        cleanTitle.length > 0 &&
        cleanTitle.length <= this.config.maxPRTitleLength
      ) {
        return cleanTitle;
      }
    } catch (error) {
      console.warn("AI title generation failed, using fallback");
    }

    // Fallback title generation
    const issueType = this.inferIssueType(originalIssue);
    const action = resolution.success ? "feat" : "fix";
    const scope = this.inferScope(resolution.solution);

    return `${action}${scope ? `(${scope})` : ""}: ${originalIssue.title.substring(0, 50)}${originalIssue.title.length > 50 ? "..." : ""}`;
  }

  /**
   * Generate comprehensive PR description
   */
  private async generatePRDescription(
    resolution: ResolutionResult,
    review: ReviewResult,
    originalIssue: { number: number; title: string; body: string },
    commits: Array<{ message: string; hash: string }>,
  ): Promise<string> {
    const sections = [
      this.generateHeader(resolution, review, originalIssue),
      this.generateChangesSummary(resolution.solution),
      this.generateReviewSummary(review),
      this.generateTestingInfo(resolution),
      this.generateCommitsList(commits),
      this.generateFooter(originalIssue),
    ];

    return sections.filter(Boolean).join("\n\n");
  }

  /**
   * Determine appropriate reviewers
   */
  private async determineReviewers(
    resolution: ResolutionResult,
    review: ReviewResult,
    originalIssue: { number: number; title: string; body: string },
  ): Promise<string[]> {
    const reviewers = new Set<string>(this.config.defaultReviewers);

    // Add reviewers based on change scope
    const scopeReviewers = this.getReviewersForScope(resolution.solution);
    scopeReviewers.forEach((reviewer) => reviewers.add(reviewer));

    // Add security reviewers for security-related changes
    if (review.issues.some((issue) => issue.category === "security")) {
      const securityReviewers = this.getSecurityReviewers();
      securityReviewers.forEach((reviewer) => reviewers.add(reviewer));
    }

    // Add reviewers based on complexity
    if (this.isHighComplexity(resolution.solution)) {
      const seniorReviewers = this.getSeniorReviewers();
      seniorReviewers.forEach((reviewer) => reviewers.add(reviewer));
    }

    return Array.from(reviewers);
  }

  /**
   * Determine appropriate labels for of PR
   */
  private determineLabels(
    resolution: ResolutionResult,
    review: ReviewResult,
    originalIssue: { number: number; title: string; body: string },
    prTitle?: string,
  ): string[] {
    const labels = [this.config.labels.autoGenerated];

    // Add review status labels
    if (!review.approved) {
      labels.push(this.config.labels.needsReview);
    }

    // Add security label if security issues found
    if (review.issues.some((issue) => issue.category === "security")) {
      labels.push(this.config.labels.security);
    }

    // Add breaking change label if detected
    if (
      this.isBreakingChange(resolution.solution) ||
      (prTitle && this.isBreakingChangeFromTitle(prTitle))
    ) {
      labels.push(this.config.labels.breaking);
    }

    // Add size-based labels
    const size = this.calculatePRSize(resolution.solution);
    if (size === "large") {
      labels.push("size/large");
    } else if (size === "medium") {
      labels.push("size/medium");
    }

    return labels;
  }

  /**
   * Update worktree status after PR creation
   */
  private async updateWorktreeStatus(
    worktree: WorktreeInfo,
    pr: PullRequest,
  ): Promise<void> {
    // Mark worktree as completed
    worktree.status = "completed";

    // Could add PR reference to worktree metadata
    console.log(`Worktree ${worktree.branch} completed with PR #${pr.number}`);
  }

  // Helper methods for commit creation
  private groupChangesForCommits(
    changes: ResolutionResult["solution"],
  ): Array<{ files: any[]; description: string }> {
    // Group related changes into logical commits
    const groups: Array<{ files: any[]; description: string }> = [];

    // Simple grouping: all changes in one commit for now
    // Could be enhanced to group by file type, functionality, etc.
    if (changes.files.length > 0) {
      groups.push({
        files: changes.files,
        description: `Implement solution for issue`,
      });
    }

    return groups;
  }

  private async generateCommitMessage(group: {
    files: any[];
    description: string;
  }): Promise<string> {
    const fileTypes = this.getFileTypes(group.files);
    const scope = this.inferCommitScope(group.files);

    let message = this.config.commitMessageTemplate
      .replace("{type}", this.inferCommitType(group.files))
      .replace("{scope}", scope)
      .replace("{description}", group.description)
      .replace("{files}", fileTypes.join(", "));

    // Truncate if too long
    if (message.length > this.config.maxCommitMessageLength) {
      message =
        message.substring(0, this.config.maxCommitMessageLength - 3) + "...";
    }

    return message;
  }

  // Git operations (simplified - would use actual git commands)
  protected async gitAdd(filePath: string): Promise<void> {
    // Implementation would use child_process to run git add
    console.log(`git add ${filePath}`);
  }

  protected async gitCommit(message: string): Promise<string> {
    // Implementation would use child_process to run git commit
    console.log(`git commit -m "${message}"`);
    return "mock-commit-hash";
  }

  protected async gitPush(branchName: string): Promise<void> {
    // Implementation would use child_process to run git push
    console.log(`git push origin ${branchName}`);
  }

  // PR content generation helpers
  private generateHeader(
    resolution: ResolutionResult,
    review: ReviewResult,
    originalIssue: { number: number; title: string; body: string },
  ): string {
    const status = review.approved ? "‚úÖ Approved" : "‚ö†Ô∏è Needs Review";
    const score = (review.score * 100).toFixed(1);

    return `## ü§ñ AI-Generated Pull Request

**Original Issue:** #${originalIssue.number} - ${originalIssue.title}
**Resolution Status:** ${resolution.success ? "Successful" : "Partial"}
**Review Status:** ${status} (Score: ${score}%)
**Complexity:** ${this.getComplexityLabel(resolution.solution)}

This pull request was automatically generated to resolve the linked issue.`;
  }

  private generateChangesSummary(
    changes: ResolutionResult["solution"],
  ): string {
    const fileCount = changes.files.length;
    const totalChanges = changes.files.reduce(
      (sum, file) => sum + file.changes.length,
      0,
    );

    let summary = `## üìù Changes Summary

- **Files Modified:** ${fileCount}
- **Total Changes:** ${totalChanges}
- **Change Types:** ${this.summarizeChangeTypes(changes)}

### Modified Files:
${changes.files.map((file) => `- \`${file.path}\` (${file.changes.length} changes)`).join("\n")}`;

    return summary;
  }

  private generateReviewSummary(review: ReviewResult): string {
    const issueCount = review.issues.length;
    const criticalCount = review.issues.filter(
      (i) => i.severity === "critical",
    ).length;
    const highCount = review.issues.filter((i) => i.severity === "high").length;

    let summary = `## üîç Code Review Results

- **Overall Score:** ${(review.score * 100).toFixed(1)}%
- **Issues Found:** ${issueCount}
- **Critical Issues:** ${criticalCount}
- **High Severity Issues:** ${highCount}

### Category Scores:
- **Static Analysis:** ${(review.metadata.staticAnalysisScore * 100).toFixed(1)}%
- **Security:** ${(review.metadata.securityScore * 100).toFixed(1)}%
- **Code Quality:** ${(review.metadata.qualityScore * 100).toFixed(1)}%
- **Testing:** ${(review.metadata.testCoverageScore * 100).toFixed(1)}%
- **Documentation:** ${(review.metadata.documentationScore * 100).toFixed(1)}%`;

    if (review.recommendations.length > 0) {
      summary += `\n\n### Recommendations:\n${review.recommendations.map((rec) => `- ${rec}`).join("\n")}`;
    }

    return summary;
  }

  private generateTestingInfo(resolution: ResolutionResult): string {
    let testing = `## üß™ Testing Information

**Tests Executed:** ${resolution.testsPassed !== undefined ? (resolution.testsPassed ? "‚úÖ Passed" : "‚ùå Failed") : "Not Run"}
**Test Coverage:** ${this.estimateTestCoverage(resolution.solution)}%`;

    if (resolution.testsPassed === false) {
      testing +=
        "\n\n‚ö†Ô∏è **Warning:** Automated tests failed. Manual testing recommended.";
    }

    return testing;
  }

  private generateCommitsList(
    commits: Array<{ message: string; hash: string }>,
  ): string {
    if (commits.length === 0) return "";

    return `## üìã Commits

${commits.map((commit) => `- ${commit.hash.substring(0, 7)}: ${commit.message}`).join("\n")}`;
  }

  private generateFooter(originalIssue: {
    number: number;
    title: string;
    body: string;
  }): string {
    return `## üîó Related

- **Closes:** #${originalIssue.number}
- **Original Issue:** ${originalIssue.title}

---
*This PR was automatically generated by the AI-powered GitHub Issues Reviewer system.*`;
  }

  // Reviewer determination helpers
  private getReviewersForScope(
    changes: ResolutionResult["solution"],
  ): string[] {
    const reviewers: string[] = [];

    // Check for frontend changes
    if (
      changes.files.some(
        (f) => f.path.includes("component") || f.path.includes("ui"),
      )
    ) {
      reviewers.push("frontend-lead");
    }

    // Check for backend changes
    if (
      changes.files.some(
        (f) => f.path.includes("api") || f.path.includes("server"),
      )
    ) {
      reviewers.push("backend-lead");
    }

    // Check for infrastructure changes
    if (
      changes.files.some(
        (f) => f.path.includes("config") || f.path.includes("docker"),
      )
    ) {
      reviewers.push("devops-lead");
    }

    return reviewers;
  }

  private getSecurityReviewers(): string[] {
    return ["security-lead", "compliance-officer"];
  }

  private getSeniorReviewers(): string[] {
    return ["tech-lead", "architect"];
  }

  // GitHub API integration (simplified)
  protected async createGitHubPR(params: {
    title: string;
    body: string;
    head: string;
    base: string;
    reviewers: string[];
    labels: string[];
  }): Promise<PullRequest> {
    // Implementation would use GitHub API
    console.log("Creating PR:", params);

    // Generate deterministic PR number based on title hash for testing
    const hash = this.simpleHash(params.title);
    const prNumber = (hash % 1000) + 1;

    // Mock response for now
    return {
      number: prNumber,
      title: params.title,
      body: params.body,
      html_url: `https://github.com/${this.config.repository.owner}/${this.config.repository.name}/pull/${prNumber}`,
      state: "open",
      merged: false,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
  }

  // Simple hash function for deterministic PR number generation
  private simpleHash(str: string): number {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return Math.abs(hash);
  }

  // Utility methods
  private summarizeChanges(changes: ResolutionResult["solution"]): string {
    const fileCount = changes.files.length;
    const changeCount = changes.files.reduce(
      (sum, file) => sum + file.changes.length,
      0,
    );
    return `${changeCount} changes across ${fileCount} files`;
  }

  private inferIssueType(issue: {
    number: number;
    title: string;
    body: string;
  }): string {
    const title = issue.title.toLowerCase();
    const body = issue.body.toLowerCase();

    if (
      title.includes("fix") ||
      title.includes("bug") ||
      body.includes("error")
    ) {
      return "bug";
    }
    if (
      title.includes("add") ||
      title.includes("feature") ||
      title.includes("implement")
    ) {
      return "feature";
    }
    if (title.includes("docs") || body.includes("documentation")) {
      return "documentation";
    }

    return "enhancement";
  }

  private inferScope(changes: ResolutionResult["solution"]): string {
    const paths = changes.files.map((f) => f.path);

    if (paths.some((p) => p.includes("component") || p.includes("ui")))
      return "frontend";
    if (paths.some((p) => p.includes("api") || p.includes("server")))
      return "backend";
    if (paths.some((p) => p.includes("test"))) return "testing";
    if (paths.some((p) => p.includes("config"))) return "config";

    return "";
  }

  private inferCommitType(files: any[]): string {
    if (files.some((f) => f.path.includes("test"))) return "test";
    if (files.some((f) => f.path.includes("docs"))) return "docs";
    if (files.some((f) => f.path.includes("config"))) return "ci";
    return "feat";
  }

  private getFileTypes(files: any[]): string[] {
    return [...new Set(files.map((f) => f.path.split(".").pop()))];
  }

  private inferCommitScope(files: any[]): string {
    return this.inferScope({ files } as ResolutionResult["solution"]);
  }

  private summarizeChangeTypes(changes: ResolutionResult["solution"]): string {
    const types = changes.files.flatMap((f) => f.changes.map((c) => c.type));
    const typeCounts = types.reduce(
      (acc, type) => {
        acc[type] = (acc[type] || 0) + 1;
        return acc;
      },
      {} as Record<string, number>,
    );

    return Object.entries(typeCounts)
      .map(([type, count]) => `${count} ${type}`)
      .join(", ");
  }

  private getComplexityLabel(changes: ResolutionResult["solution"]): string {
    const fileCount = changes.files.length;
    const changeCount = changes.files.reduce(
      (sum, file) => sum + file.changes.length,
      0,
    );

    if (fileCount > 10 || changeCount > 50) return "High";
    if (fileCount > 5 || changeCount > 20) return "Medium";
    return "Low";
  }

  private isHighComplexity(changes: ResolutionResult["solution"]): boolean {
    const fileCount = changes.files.length;
    const changeCount = changes.files.reduce(
      (sum, file) => sum + file.changes.length,
      0,
    );
    return fileCount > 5 || changeCount > 25;
  }

  private isBreakingChange(changes: ResolutionResult["solution"]): boolean {
    // Check for breaking patterns in changes
    return changes.files.some((file) =>
      file.changes.some(
        (change) =>
          change.content.includes("BREAKING") ||
          change.content.includes("breaking") ||
          change.content.includes("!"), // Conventional commit breaking indicator
      ),
    );
  }

  // Additional breaking change detection for titles
  isBreakingChangeFromTitle(title: string): boolean {
    return (
      title.includes("!:") ||
      title.includes("BREAKING") ||
      title.includes("breaking")
    );
  }

  private calculatePRSize(
    changes: ResolutionResult["solution"],
  ): "small" | "medium" | "large" {
    const fileCount = changes.files.length;
    const changeCount = changes.files.reduce(
      (sum, file) => sum + file.changes.length,
      0,
    );

    if (fileCount > 10 || changeCount > 100) return "large";
    if (fileCount > 3 || changeCount > 20) return "medium";
    return "small";
  }

  private estimateTestCoverage(changes: ResolutionResult["solution"]): number {
    // Simple estimation based on presence of test files
    const hasTests = changes.files.some(
      (file) =>
        file.path.includes(".test.") ||
        file.path.includes(".spec.") ||
        file.path.includes("/tests/") ||
        file.path.includes("/test/"),
    );

    return hasTests ? 80 : 0; // Rough estimate
  }
}
