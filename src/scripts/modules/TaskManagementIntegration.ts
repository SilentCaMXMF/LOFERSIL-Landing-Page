/**
 * Task Management Integration for GitHub Issues Reviewer System
 *
 * This module integrates the AI-powered GitHub Issues Reviewer with the main
 * task management system, providing endpoints for task creation, assignment,
 * progress tracking, and automation triggers.
 */

import { GitHubIssuesReviewer } from "./github-issues/GitHubIssuesReviewer";
import { WorkflowOrchestrator } from "./github-issues/WorkflowOrchestrator";
import { IssueAnalyzer } from "./github-issues/IssueAnalyzer";
import { AutonomousResolver } from "./github-issues/AutonomousResolver";
import { CodeReviewer } from "./github-issues/CodeReviewer";
import { PRGenerator } from "./github-issues/PRGenerator";
import { WorktreeManager } from "./github-issues/WorktreeManager";
import { TaskManager, TaskInfo } from "./TaskManager";
import {
  GitHubConfig,
  AIConfig,
  AnalysisConfig,
  IssueAnalysis,
} from "./github-issues/types";
import {
  AutomationTriggersManager,
  AutomationEvent,
} from "./AutomationTriggers";
import { MonitoringReportingManager } from "./MonitoringReporting";
import { GitHubProjectsIntegration } from "./github-projects";
import { OpenCodeAgent } from "./OpenCodeAgent";
import { logger } from "./logger";

export interface TaskManagementConfig {
  enableAutomation: boolean;
  autoAssignment: boolean;
  progressTracking: boolean;
  reportingEnabled: boolean;
  webhookEndpoints: string[];
  github: GitHubConfig;
  ai: AIConfig;
  analysis: AnalysisConfig;
}

// Re-export TaskInfo from TaskManager
export type { TaskInfo } from "./TaskManager";

export interface AutomationTrigger {
  event: string;
  condition: string;
  action: string;
  enabled: boolean;
}

/**
 * Main Task Management Integration Class
 */
export class TaskManagementIntegration {
  private config: TaskManagementConfig;
  private reviewer: GitHubIssuesReviewer;
  private orchestrator: WorkflowOrchestrator;
  private taskManager: TaskManager;
  private automationTriggers: AutomationTrigger[] = [];
  private automationManager: AutomationTriggersManager;
  private monitoringManager: MonitoringReportingManager;
  private kanbanIntegration?: GitHubProjectsIntegration;

  constructor(config: TaskManagementConfig) {
    this.config = config;
    this.reviewer = new GitHubIssuesReviewer(
      config.github,
      config.ai,
      config.analysis,
    );

    // Initialize OpenCode agent for AI components
    const openCodeAgent = new OpenCodeAgent();

    // Initialize workflow components with default configurations
    const issueAnalyzer = new IssueAnalyzer({
      openCodeAgent,
      complexityThresholds: {
        low: 3,
        medium: 7,
        high: 15,
      },
      maxAnalysisTime: 5 * 60 * 1000, // 5 minutes
      supportedLabels: ["bug", "feature", "enhancement", "documentation"],
    });

    const worktreeManager = new WorktreeManager({
      rootDir: process.cwd(),
      autoCleanup: true,
      defaultSyncStrategy: "merge",
      mainBranch: "main",
      copyFiles: [".env.example", ".env.local", "package-lock.json"],
    });

    const autonomousResolver = new AutonomousResolver({
      openCodeAgent,
      worktreeManager,
      maxIterations: 3,
      maxExecutionTime: 10 * 60 * 1000, // 10 minutes
      testCommand: "npm test",
      allowedFileExtensions: [".ts", ".js", ".json", ".md"],
      safetyChecks: {
        maxFilesModified: 10,
        maxLinesChanged: 500,
        requireTests: true,
      },
    });

    const codeReviewer = new CodeReviewer({
      openCodeAgent,
      minApprovalScore: 0.8,
      strictMode: true,
      securityScanEnabled: true,
      performanceAnalysisEnabled: true,
      documentationRequired: false,
      maxReviewTime: 5 * 60 * 1000, // 5 minutes
    });

    const prGenerator = new PRGenerator({
      openCodeAgent,
      githubToken: process.env.GITHUB_TOKEN || "",
      repository: {
        owner: process.env.GITHUB_REPOSITORY_OWNER || "",
        name: process.env.GITHUB_REPOSITORY_NAME || "",
      },
      baseBranch: "main",
      commitMessageTemplate: "fix: {issueTitle} (closes #{issueNumber})",
      prTitleTemplate: "[AI] {issueTitle}",
      prBodyTemplate:
        "## Summary\n\n{summary}\n\n## Changes\n\n{changes}\n\n## Testing\n\n{testing}",
      defaultReviewers: [],
      labels: {
        autoGenerated: "ai-generated",
        needsReview: "needs-review",
        security: "security",
        breaking: "breaking-change",
      },
      maxCommitMessageLength: 72,
      maxPRTitleLength: 50,
    });

    this.orchestrator = new WorkflowOrchestrator({
      issueAnalyzer,
      autonomousResolver,
      codeReviewer,
      prGenerator,
      maxWorkflowTime: 30 * 60 * 1000, // 30 minutes
      enableMetrics: true,
      retryAttempts: 3,
      humanInterventionThreshold: 0.7,
    });

    this.taskManager = new TaskManager();
    this.automationManager = new AutomationTriggersManager();
    this.monitoringManager = new MonitoringReportingManager(
      this.automationManager,
    );
    this.initializeAutomationTriggers();
    this.initializeKanbanIntegration();
  }

  /**
   * Initialize default automation triggers
   */
  private initializeAutomationTriggers(): void {
    this.automationTriggers = [
      {
        event: "issue.created",
        condition: 'labels.includes("bug") && priority === "high"',
        action: "auto-assign-to-senior-dev",
        enabled: this.config.autoAssignment,
      },
      {
        event: "workflow.completed",
        condition: "result.success === true",
        action: "update-task-status",
        enabled: this.config.progressTracking,
      },
      {
        event: "workflow.failed",
        condition: 'result.error === "human_intervention_required"',
        action: "create-escalation-task",
        enabled: this.config.enableAutomation,
      },
      {
        event: "task.updated",
        condition: 'status === "completed"',
        action: "generate-completion-report",
        enabled: this.config.reportingEnabled,
      },
    ];
  }

  /**
   * Initialize GitHub Projects (Kanban) integration
   */
  private initializeKanbanIntegration(): void {
    const accessToken = process.env.GITHUB_ACCESS_TOKEN;
    const projectId = process.env.GITHUB_PROJECT_ID;
    const owner = process.env.GITHUB_REPOSITORY_OWNER;
    const repo = process.env.GITHUB_REPOSITORY_NAME;

    if (accessToken && projectId && owner && repo) {
      try {
        this.kanbanIntegration = new GitHubProjectsIntegration(
          accessToken,
          projectId,
          owner,
          repo,
        );
        logger.info("GitHub Projects integration initialized", {
          projectId,
          owner,
          repo,
        });
      } catch (error: any) {
        logger.error("Failed to initialize GitHub Projects integration", {
          error: error.message,
        });
      }
    } else {
      logger.info("GitHub Projects integration not configured - skipping");
    }
  }

  /**
   * Create a new task from GitHub issue
   */
  async createTaskFromIssue(issueNumber: number): Promise<TaskInfo> {
    try {
      // Get the issue data first
      const issue = await this.reviewer.getIssue(issueNumber);

      // Analyze the issue
      const analysis = await this.reviewer.analyzeIssue(issueNumber);

      // Create task object
      const task: TaskInfo = {
        id: `task-${issueNumber}-${Date.now()}`,
        title: `Issue #${issueNumber}: ${issue.title}`,
        description: issue.body || "",
        priority: this.mapPriority(analysis.classification.priority),
        status: "pending",
        labels: analysis.classification.labels,
        createdAt: new Date(),
        updatedAt: new Date(),
        metadata: {
          issueNumber,
          analysis: analysis.reasoning,
          estimatedComplexity: analysis.estimatedEffort.complexity,
          suggestedApproach: analysis.reasoning,
          category: analysis.category,
        },
      };

      // Save task
      await this.taskManager.saveTask(task);

      // Create kanban card if integration is available
      if (this.kanbanIntegration) {
        try {
          await this.kanbanIntegration.createCard({
            title: task.title,
            body: `## Task Description\n${task.description}\n\n## Metadata\n- **Priority:** ${task.priority}\n- **Labels:** ${task.labels.join(", ") || "None"}\n- **Created:** ${task.createdAt.toISOString()}\n- **Task ID:** ${task.id}`,
            status: "Backlog",
            assignees: task.assignee ? [task.assignee] : [],
            labels: [...task.labels, "ai-generated"],
            issueNumber: issueNumber,
            taskId: task.id,
          });
          logger.info("Created kanban card for new task", {
            taskId: task.id,
            issueNumber,
          });
        } catch (error: any) {
          logger.error("Failed to create kanban card", {
            taskId: task.id,
            error: error.message,
          });
          // Don't fail the task creation if kanban fails
        }
      }

      // Trigger automation if enabled
      if (this.config.enableAutomation) {
        await this.triggerAutomation("issue.created", task);
      }

      return task;
    } catch (error) {
      console.error("Failed to create task from issue:", error);
      throw error;
    }
  }

  /**
   * Assign task to team member
   */
  async assignTask(taskId: string, assignee: string): Promise<TaskInfo> {
    const task = await this.taskManager.getTask(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    task.assignee = assignee;
    task.status = "in_progress";
    task.updatedAt = new Date();

    await this.taskManager.updateTask(task);
    await this.triggerAutomation("task.assigned", task);

    return task;
  }

  /**
   * Process task with AI workflow
   */
  async processTask(taskId: string): Promise<any> {
    const task = await this.taskManager.getTask(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    try {
      // Update task status
      task.status = "in_progress";
      task.updatedAt = new Date();
      await this.taskManager.updateTask(task);

      // Update kanban status
      await this.syncTaskWithKanban(taskId);

      // Update workflow progress (25% - started)
      await this.updateWorkflowProgress(
        task.metadata.issueNumber,
        taskId,
        "Analysis Started",
        25,
      );

      // Run workflow
      const result = await this.orchestrator.processIssue(
        task.metadata.issueNumber,
      );

      // Update workflow progress (75% - processing complete)
      await this.updateWorkflowProgress(
        task.metadata.issueNumber,
        taskId,
        "Processing Complete",
        75,
      );

      // Update task based on result
      if (result.success) {
        task.status = "completed";
        task.metadata.result = result;

        // Update workflow progress (100% - completed)
        await this.updateWorkflowProgress(
          task.metadata.issueNumber,
          taskId,
          "Workflow Completed",
          100,
        );
      } else {
        task.status = "blocked";
        task.metadata.error = result.error;
      }

      task.updatedAt = new Date();
      await this.taskManager.updateTask(task);

      // Sync final status with kanban
      await this.syncTaskWithKanban(taskId);

      // Trigger automation
      await this.triggerAutomation(
        result.success ? "workflow.completed" : "workflow.failed",
        task,
      );

      return result;
    } catch (error) {
      task.status = "blocked";
      task.metadata.error = error;
      task.updatedAt = new Date();
      await this.taskManager.updateTask(task);

      await this.triggerAutomation("workflow.failed", task);
      throw error;
    }
  }

  /**
   * Sync task status with kanban board
   */
  async syncTaskWithKanban(taskId: string): Promise<void> {
    if (!this.kanbanIntegration) {
      return; // Kanban integration not configured
    }

    try {
      const task = await this.taskManager.getTask(taskId);
      if (!task) {
        logger.warn("Task not found for kanban sync", { taskId });
        return;
      }

      const issueNumber = task.metadata?.issueNumber;
      if (!issueNumber) {
        logger.warn("Task has no associated issue number", { taskId });
        return;
      }

      await this.kanbanIntegration.syncTaskStatus(
        taskId,
        task.status,
        issueNumber,
      );
    } catch (error: any) {
      logger.error("Failed to sync task with kanban", {
        taskId,
        error: error.message,
      });
    }
  }

  /**
   * Update workflow progress on kanban board
   */
  async updateWorkflowProgress(
    issueNumber: number,
    taskId: string,
    stage: string,
    progress: number,
  ): Promise<void> {
    if (!this.kanbanIntegration) {
      return; // Kanban integration not configured
    }

    try {
      await this.kanbanIntegration.updateWorkflowProgress(
        issueNumber,
        taskId,
        stage,
        progress,
      );
    } catch (error: any) {
      logger.error("Failed to update workflow progress on kanban", {
        issueNumber,
        taskId,
        stage,
        progress,
        error: error.message,
      });
    }
  }

  /**
   * Get task statistics
   */
  async getTaskStatistics(): Promise<any> {
    const tasks = await this.taskManager.getAllTasks();

    const stats = {
      total: tasks.length,
      byStatus: {
        pending: tasks.filter((t) => t.status === "pending").length,
        in_progress: tasks.filter((t) => t.status === "in_progress").length,
        completed: tasks.filter((t) => t.status === "completed").length,
        blocked: tasks.filter((t) => t.status === "blocked").length,
      },
      byPriority: {
        low: tasks.filter((t) => t.priority === "low").length,
        medium: tasks.filter((t) => t.priority === "medium").length,
        high: tasks.filter((t) => t.priority === "high").length,
        critical: tasks.filter((t) => t.priority === "critical").length,
      },
      averageCompletionTime: this.calculateAverageCompletionTime(tasks),
      successRate: this.calculateSuccessRate(tasks),
    };

    return stats;
  }

  /**
   * Trigger automation based on event and conditions
   */
  private async triggerAutomation(
    event: string,
    task: TaskInfo,
  ): Promise<void> {
    if (!this.config.enableAutomation) return;

    const applicableTriggers = this.automationTriggers.filter(
      (trigger) => trigger.enabled && trigger.event === event,
    );

    for (const trigger of applicableTriggers) {
      if (this.evaluateCondition(trigger.condition, task)) {
        await this.executeAction(trigger.action, task);
      }
    }
  }

  /**
   * Evaluate trigger condition
   */
  private evaluateCondition(condition: string, task: TaskInfo): boolean {
    try {
      // Simple condition evaluation - in production, use a safer expression parser
      const context = {
        task,
        labels: task.labels,
        priority: task.priority,
        status: task.status,
        assignee: task.assignee,
      };

      // Basic condition matching (this is simplified for safety)
      if (condition.includes('labels.includes("bug")')) {
        return task.labels.includes("bug");
      }
      if (condition.includes('priority === "high"')) {
        return task.priority === "high";
      }
      if (condition.includes('status === "completed"')) {
        return task.status === "completed";
      }

      return false;
    } catch (error) {
      console.error("Error evaluating condition:", error);
      return false;
    }
  }

  /**
   * Execute automation action
   */
  private async executeAction(action: string, task: TaskInfo): Promise<void> {
    switch (action) {
      case "auto-assign-to-senior-dev":
        // Implementation for auto-assignment
        console.log(`Auto-assigning task ${task.id} to senior developer`);
        break;

      case "update-task-status":
        // Status is already updated in the calling method
        break;

      case "create-escalation-task":
        await this.createEscalationTask(task);
        break;

      case "generate-completion-report":
        await this.generateCompletionReport(task);
        break;

      default:
        console.warn(`Unknown automation action: ${action}`);
    }
  }

  /**
   * Create escalation task for blocked issues
   */
  private async createEscalationTask(originalTask: TaskInfo): Promise<void> {
    const escalationTask: TaskInfo = {
      id: `escalation-${originalTask.id}-${Date.now()}`,
      title: `Escalation: ${originalTask.title}`,
      description: `Original task ${originalTask.id} requires human intervention. Error: ${originalTask.metadata.error}`,
      priority: "high",
      status: "pending",
      labels: ["escalation", "human-intervention-required"],
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata: {
        originalTaskId: originalTask.id,
        escalationReason: originalTask.metadata.error,
      },
    };

    await this.taskManager.saveTask(escalationTask);
  }

  /**
   * Generate completion report
   */
  private async generateCompletionReport(task: TaskInfo): Promise<void> {
    const report = {
      taskId: task.id,
      title: task.title,
      completedAt: new Date(),
      duration: this.calculateTaskDuration(task),
      result: task.metadata.result,
      complexity: task.metadata.estimatedComplexity,
      success: task.status === "completed",
    };

    // Save report (implementation depends on your reporting system)
    console.log("Completion report generated:", report);
  }

  /**
   * Map analysis priority to task priority
   */
  private mapPriority(analysisPriority: string): TaskInfo["priority"] {
    switch (analysisPriority.toLowerCase()) {
      case "critical":
        return "critical";
      case "high":
        return "high";
      case "medium":
        return "medium";
      case "low":
        return "low";
      default:
        return "medium";
    }
  }

  /**
   * Calculate average completion time
   */
  private calculateAverageCompletionTime(tasks: TaskInfo[]): number {
    const completedTasks = tasks.filter(
      (t: TaskInfo) => t.status === "completed",
    );
    if (completedTasks.length === 0) return 0;

    const totalTime = completedTasks.reduce((sum, task) => {
      return sum + this.calculateTaskDuration(task);
    }, 0);

    return totalTime / completedTasks.length;
  }

  /**
   * Calculate task duration in hours
   */
  private calculateTaskDuration(task: TaskInfo): number {
    const endTime = task.status === "completed" ? task.updatedAt : new Date();
    return (endTime.getTime() - task.createdAt.getTime()) / (1000 * 60 * 60);
  }

  /**
   * Calculate success rate
   */
  private calculateSuccessRate(tasks: TaskInfo[]): number {
    const processedTasks = tasks.filter(
      (t: TaskInfo) => t.status === "completed" || t.status === "blocked",
    );

    if (processedTasks.length === 0) return 0;

    const successfulTasks = processedTasks.filter(
      (t: TaskInfo) => t.status === "completed",
    );
    return (successfulTasks.length / processedTasks.length) * 100;
  }

  /**
   * Get system health status
   */
  async getSystemHealth(): Promise<any> {
    const stats = await this.getTaskStatistics();
    const systemHealth = {
      overall: "healthy" as "healthy" | "warning" | "critical",
      issues: [] as string[],
      metrics: {
        taskProcessingRate: stats.successRate,
        averageProcessingTime: stats.averageCompletionTime,
        activeTasks: stats.byStatus.in_progress + stats.byStatus.pending,
        blockedTasks: stats.byStatus.blocked,
      },
    };

    // Determine overall health
    if (stats.successRate < 50) {
      systemHealth.overall = "critical";
      systemHealth.issues = [...systemHealth.issues, "Low success rate"];
    } else if (stats.successRate < 75) {
      systemHealth.overall = "warning";
      systemHealth.issues = [...systemHealth.issues, "Moderate success rate"];
    }

    if (stats.byStatus.blocked > stats.total * 0.2) {
      systemHealth.overall = "warning";
      systemHealth.issues = [
        ...systemHealth.issues,
        "High number of blocked tasks",
      ];
    }

    return systemHealth;
  }

  /**
   * Get automation manager instance
   */
  getAutomationManager(): AutomationTriggersManager {
    return this.automationManager;
  }

  /**
   * Get monitoring manager instance
   */
  getMonitoringManager(): MonitoringReportingManager {
    return this.monitoringManager;
  }

  /**
   * Get all tasks - API method
   */
  async getAllTasks(): Promise<TaskInfo[]> {
    return await this.taskManager.getAllTasks();
  }

  /**
   * Get task by ID - API method
   */
  async getTask(taskId: string): Promise<TaskInfo | null> {
    return await this.taskManager.getTask(taskId);
  }

  /**
   * Update task - API method
   */
  async updateTask(
    taskId: string,
    updates: Partial<TaskInfo>,
  ): Promise<TaskInfo> {
    const task = await this.taskManager.getTask(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    // Apply updates
    Object.assign(task, updates);
    task.updatedAt = new Date();

    await this.taskManager.updateTask(task);
    await this.syncTaskWithKanban(taskId);

    return task;
  }

  /**
   * Delete task - API method
   */
  async deleteTask(taskId: string): Promise<void> {
    await this.taskManager.deleteTask(taskId);
  }
}
